diff=mice2$before-mice2$after
shapiro.test(diff)
mice2
# (i).
#a. Null: There is no significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits. Ua-Ub=0
#Alt: There is a significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits.Ua-Ub is not equal to zero.
boxplot(Fruit$Shaded,Fruit$Exposed,names=c("Shaded", "Exposed"))
# (i).
#a. Null: There is no significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits. Ua-Ub=0
#Alt: There is a significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits.Ua-Ub is not equal to zero.
boxplot(GrapeFruit$Shaded,GrapeFruit$Exposed,names=c("Shaded", "Exposed"))
diff=GrapeFruit$Shaded-GrapeFruit$Exposed
shapiro.t
# (i).
#a. Null: There is no significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits. Ua-Ub=0
#Alt: There is a significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits.Ua-Ub is not equal to zero.
boxplot(GrapeFruit$Shaded,GrapeFruit$Exposed,names=c("Shaded", "Exposed"))
diff=GrapeFruit$Shaded-GrapeFruit$Exposed
shapiro.test(diff)
# install.packages("datarium")
library(datarium)
mice2
boxplot(mice2$before,mice2$after,names=c("before", "after"))
diff=mice2$before-mice2$after
shapiro.test(diff)
# (i).
#a. Null: There is no significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits. Ua-Ub=0
#Alt: There is a significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits.Ua-Ub is not equal to zero.
boxplot(GrapeFruit$Shaded,GrapeFruit$Exposed,names=c("Shaded", "Exposed"))
diff=GrapeFruit$Shaded-GrapeFruit$Exposed
shapiro.test(diff)
t.test(GrapeFruit$Shaded,GrapeFruit$Exposedr, alternative = "two.sided", paired = TRUE, conf.level = 0.95)
t.test(GrapeFruit$Shaded,GrapeFruit$Exposed, alternative = "two.sided", paired = TRUE, conf.level = 0.95)
#b. We have dependent samples
#c. The variances are unequal across the two groups
#d. We apply paired t-test with unequal variances here.Assumptions:the distributions of the two populations are normal, and that the variances of the two distributions are not the same. It turns out that p-value = 0.1007 > 0.05 from Shapiro-Wilk test. So the conclusion is that we can assume the variances for the two samples or groups are unequal.
t.test(GrapeFruit$Shaded,GrapeFruit$Exposed, alternative = "two.sided", paired = TRUE, conf.level = 0.95)
---
title: "HW1"
author: "Sruthi Sravanam"
date: "10/24/2022"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
knitr::opts_chunk$set(echo = TRUE)
# install.packages("package_name")
library(readr)
library(readxl)
library(dplyr)
library(tidyverse)
# install.packages("DAAG")
install.packages("DAAG")
library(DAAG)
data(leafshape)
install.packages("DAAG")
# install.packages("DAAG")
library(DAAG)
data(leafshape)
# (i).
#a. Null: There is no significant difference in the average leaf length between the locations N Queensland and S Queensland. Ua-Ub=0
#Alt: There is a significant difference in the average leaf length between the locations N Queensland and S Queensland.Ua-Ub is not equal to zero.
x=subset(leafshape, location=="N Queensland")$loglen
y=subset(leafshape, location=="S Queensland")$loglen
m=length(x); n=length(y)
m;n
boxplot(x,y, names=c("N Queensland","S Queensland"))
#d. We apply two-sample t-test with equal variances here.Assumptions:the distributions of the two populations are normal, and that the variances of the two distributions are the same. It turns out that p-value = 0.2052 > 0.05. So the conclusion is that we can assume the variances for the two samples or groups are equal. Or in other words, there is no statistically significant evidence that the variances of the two groups are unequal.
ggplot(leafshape, aes(x = loglen, fill = location)) +
geom_histogram(alpha = 0.5, position = "identity")
t.test(x, y, alternative = "two.sided", paired = FALSE, var.equal = TRUE, conf.level = 0.95)
# (ii).
#a. Null: There is no significant difference in the average leaf length between the locations N Queensland and Tasmania. Ua-Ub=0
#Alt: There is a significant difference in the average leaf length between the locations N Queensland and Tasmania.Ua-Ub is not equal to zero.
x=subset(leafshape, location=="N Queensland")$loglen
y=subset(leafshape, location=="Tasmania")$loglen
m=length(x); n=length(y)
m;n
boxplot(x,y, names=c("N Queensland","Tasmania"))
#b. We have independent samples
#c. The variances are not equal across the two groups
# install.packages("car")
library(car)
dat=rbind(subset(leafshape, location=="N Queensland"),subset(leafshape, location=="Tasmania"))
is.factor(dat$location)
leveneTest(dat$loglen,as.factor(dat$location))
# install.packages("PairedData")
library(PairedData)
data(GrapeFruit)
# (i).
#a. Null: There is no significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits. Ua-Ub=0
#Alt: There is a significant difference in the percentage of solids recorded in the shaded and exposed halves of the grapefruits.Ua-Ub is not equal to zero.
boxplot(GrapeFruit$Shaded,GrapeFruit$Exposed,names=c("Shaded", "Exposed"))
diff=GrapeFruit$Shaded-GrapeFruit$Exposed
shapiro.test(diff)
#b. We have dependent samples
#c. The variances are unequal across the two groups
#d. We apply paired t-test with unequal variances here.Assumptions:the distributions of the two populations are normal, and that the variances of the two distributions are not the same. It turns out that p-value = 0.1007 > 0.05 from Shapiro-Wilk test. So the conclusion is that we can assume the variances for the two samples or groups are unequal.
t.test(GrapeFruit$Shaded,GrapeFruit$Exposed, alternative = "two.sided", paired = TRUE, conf.level = 0.95)
setwd("~/Downloads")
install.packages("tinytex")
tinytex::install_tinytex()
library(tinytex)
detach("package:tinytex", unload = TRUE)
library(tinytex)
install.packages("tinytex")
library(tinytex)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
# install.packages("ISLR2")
library(MASS)
library(ISLR2)
Credit
attach(Credit)
Credit
view(Credit)
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(lstat=c(5,10,15))) # to predict Balance for a given value of Rating
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
# install.packages("ISLR2")
library(MASS)
library(ISLR2)
Credit
attach(Credit)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
# install.packages("ISLR2")
library(MASS)
library(ISLR2)
Credit
attach(Credit)
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(lstat=c(5,10,15))) # to predict Balance for a given value of Rating
summary(lm.fit)
plot(Rating , Balance)
abline(lm.fit)
plot(predict(lm.fit), residuals(lm.fit), xlab="fitted values", ylab="residuals")
# install.packages("ISLR2")
library(MASS)
library(ISLR2)
?ISLR2::Boston
head(Boston)
attach(Boston)
lm.fit <- lm(medv ~ lstat , data = Boston)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(medv, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(lstat=c(5,10,15))) # to predict medv for a given value of lstat
plot(lstat , medv)
abline(lm.fit)
plot(predict(lm.fit), residuals(lm.fit), xlab="fitted values", ylab="residuals")
summary(lm.fit)
# recap
plot(lstat , medv)
abline(lm.fit)
plot(predict(lm.fit), residuals(lm.fit), xlab="fitted values", ylab="residuals")
lm.fit1 <- lm(medv ~ log(lstat) , data = Boston) # using the logarithm of lstat as the                                                       predictor
lm.fit1
summary(lm.fit1) # detailed information about the fitted linear model
plot(predict(lm.fit1), residuals(lm.fit1), xlab="fitted values", ylab="residuals")
plot(log(lstat) , medv, main="logarithmic transformation")
abline(lm.fit1)
lm.fit2 <- lm(medv ~ lstat + I(lstat^2) , data = Boston) # adding a quadratic term
lm.fit2
summary(lm.fit2) # detailed information about the fitted linear model
plot(predict(lm.fit2), residuals(lm.fit2), xlab="fitted values", ylab="residuals")
plot(lstat , medv, main="quadratic fit")
lines(sort(lstat), predict(lm.fit2)[order(lstat)])
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
# install.packages("ISLR2")
library(MASS)
library(ISLR2)
Credit
attach(Credit)
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(lstat=c(5,10,15))) # to predict Balance for a given value of Rating
# recap
plot(Rating , Balance)
abline(lm.fit)
plot(predict(lm.fit), residuals(lm.fit), xlab="fitted values", ylab="residuals")
lm.fit1 <- lm(Balance ~ log(Rating) , data = Credit) # using the logarithm of Rating as the                                     predictor
lm.fit1
summary(lm.fit1) # detailed information about the fitted linear model
plot(predict(lm.fit1), residuals(lm.fit1), xlab="fitted values", ylab="residuals")
plot(log(Rating) , Balance, main="logarithmic transformation")
abline(lm.fit1)
lm.fit4 <- lm(Balance ~ Rating + I(Rating^2) + I(Rating^3) + I(Rating^4), data = Credit) # adding a 4 degree polynomial
summary(lm.fit4) # detailed information about the fitted linear model
plot(predict(lm.fit4), residuals(lm.fit4), xlab="fitted values", ylab="residuals")
plot(Rating , Balance, main="Quadric fit")
lines(sort(Rating), predict(lm.fit4)[order(Rating)])
lm.fit4 <- lm(Balance ~ poly(Rating, degree=4, raw=TRUE) , data = Credit) # produces the same output
summary(lm.fit4)
summary(lm.fit1)
lm.fit4 <- lm(Balance ~ poly(Rating, degree=4, raw=TRUE) , data = Credit) # produces the same output
summary(lm.fit4)
anova(lm.fit, lm.fit4)
lm.fit4 <- lm(Balance ~ poly(Rating, degree=4, raw=TRUE) , data = Credit) # produces the same output
summary(lm.fit4)
anova(lm.fit, lm.fit4)
AIC(lm.fit)
AIC(lm.fit4)
lm.all <- lm(Balance ~ ., data = Credit) # fits the full model
summary(lm.all)
summary(lm.all)$r.squared
AIC(lm.all)
vif(lm.all) # computes the variance inflation factors
lm.all <- lm(Balance ~ ., data = Credit) # fits the full model
summary(lm.all)
summary(lm.all)$r.squared
AIC(lm.all)
library(car)
vif(lm.all) # computes the variance inflation factors
lm.all <- lm(medv ~ ., data = Boston) # fits the full model
summary(lm.all)
summary(lm.all)$r.squared
AIC(lm.all)
library(car)
vif(lm.all) # computes the variance inflation factors
lm.all <- lm(Balance ~ ., data = Credit) # fits the full model
summary(lm.all)
summary(lm.all)$r.squared
AIC(lm.all)
library(car)
vif(lm.all) # computes the variance inflation factors
lm.all <- lm(Balance ~ ., data = Credit) # fits the full model
summary(lm.all)
summary(lm.all)$r.squared
AIC(lm.all)
library(car)
vif(lm.all) # computes the variance inflation factors
intercept_only <- lm(Balance ~ 1 , data = Credit) # the model that has only the intercept parameter
summary(intercept_only)
forward <- step(intercept_only, direction="forward", scope=formula(lm.all), trace=0)
forward$anova # displays the forward selection procedure and the variables selected at each step
forward$coefficients # displays the coefficients for the best subset model fitted
AIC(lm.all); BIC(lm.all) # to obtain the AIC and BIC values
intercept_only <- lm(Balance ~ 1 , data = Credit) # the model that has only the intercept parameter
summary(intercept_only)
forward <- step(intercept_only, direction="forward", scope=formula(lm.all), trace=0)
forward$anova # displays the forward selection procedure and the variables selected at each step
forward$coefficients # displays the coefficients for the best subset model fitted
intercept_only_qual <- lm(Sales ~ 1 , data = Carseats) # the model with only the intercept term
summary(intercept_only_qual)
forward_qual <- step(intercept_only_qual, direction="forward", scope=formula(lm.qual), trace=0)
?Carseats
head(Carseats)
lm.qual <- lm(Sales ~ ., data = Carseats) # fitting the full model
summary(lm.qual)
intercept_only_qual <- lm(Sales ~ 1 , data = Carseats) # the model with only the intercept term
summary(intercept_only_qual)
forward_qual <- step(intercept_only_qual, direction="forward", scope=formula(lm.qual), trace=0)
forward_qual$anova # displays the forward selection procedure and the variables selected at each step
forward_qual$coefficients # displays the coefficients for the best subset model fitted
AIC(lm.all); BIC(lm.all) # to obtain the AIC and BIC values
intercept_only <- lm(Balance ~ 1 , data = Credit) # the model that has only the intercept parameter
summary(intercept_only)
forward <- step(intercept_only, direction="forward", scope=formula(lm.all), trace=0)
forward$anova # displays the forward selection procedure and the variables selected at each step
forward$coefficients # displays the coefficients for the best subset model fitted
lm.fit3 <- lm(Balance ~ poly(Rating,Income,Student,Limit,Cards,Age, degree=4, raw=TRUE) , data = Credit) # produces the same output
lm.fit3 <- lm(Balance ~ poly(Rating+Income+Student+Limit+Cards+Age, degree=4, raw=TRUE) , data = Credit) # produces the same output
lm.fit3 <- lm(Balance ~ poly(Rating)+poly(Income), degree=4, raw=TRUE, data = Credit) # produces the same output
summary(lm.fit3)
lm.fit3 <- lm(Balance ~ poly(Rating)+poly(Income), degree=4, raw=TRUE, data = Credit) # produces the same output
summary(lm.fit3)
anova(lm.fit, lm.fit2, lm.fit3, lm.all)
lm.fit3 <- lm(Balance ~ poly(Rating)+poly(Income), degree=4, raw=TRUE, data = Credit) # produces the same output
summary(lm.fit3)
anova(lm.fit, lm.fit4, lm.fit4, lm.all)
lm.fit3 <- lm(Balance ~ poly(Rating)+poly(Income), degree=4, raw=TRUE, data = Credit) # produces the same output
summary(lm.fit3)
anova(lm.fit, lm.fit3, lm.fit4, lm.all)
lm.fit3 <- lm(Balance ~ Rating+Income+Student+Limit+Cards+Age, data = Credit)
summary(lm.fit3)
anova(lm.fit3, lm.fit4)
lm.fit3 <- lm(Balance ~ poly(Rating)+Income+Student+Limit+Cards+Age, data = Credit)
summary(lm.fit3)
anova(lm.fit3, lm.all)
lm.fit3 <- lm(Balance ~ poly(Rating)+Income+Student+Limit+Cards+Age, data = Credit)
summary(lm.fit3)
anova(lm.fit3, lm.all)
lm.fit4 <- lm(Balance ~ poly(Rating, degree=4, raw=TRUE) , data = Credit) # produces the same output
summary(lm.fit4)
anova(lm.fit, lm.fit4)
AIC(lm.fit)
AIC(lm.fit4)
lm.fitc <- lm(Balance ~ Rating+Income+Student+Limit+Cards+Age, data = Credit)
summary(lm.fitc)#Model M1
lm.fit3 <- lm(Balance ~ poly(Rating)+Income+Student+Limit+Cards+Age, data = Credit)
summary(lm.fit3)#Model M2
anova(lm.fitc, lm.fit3)
lm.fitc <- lm(Balance ~ Rating+Income+Student+Limit+Cards+Age, data = Credit)
summary(lm.fitc)#Model M1
lm.fit3 <- lm(Balance ~ poly(Rating)+poly(Income)+Student+Limit+Cards+Age, data = Credit)
summary(lm.fit3)#Model M2
anova(lm.fitc, lm.fit3)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
# install.packages("ISLR2")
library(MASS)
library(ISLR2)
Credit
attach(Credit)
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(lstat=c(5,10,15))) # to predict Balance for a given value of Rating
plot(Rating , Balance)
abline(lm.fit)
plot(predict(lm.fit), residuals(lm.fit), xlab="fitted values", ylab="residuals")
lm.fit1 <- lm(Balance ~ log(Rating) , data = Credit) # using the logarithm of Rating as the                                     predictor
lm.fit1
summary(lm.fit1) # detailed information about the fitted linear model
plot(predict(lm.fit1), residuals(lm.fit1), xlab="fitted values", ylab="residuals")
plot(log(Rating) , Balance, main="logarithmic transformation")
abline(lm.fit1)
lm.fit4 <- lm(Balance ~ poly(Rating, degree=4, raw=TRUE) , data = Credit) # produces the same output
summary(lm.fit4)
anova(lm.fit, lm.fit4)
AIC(lm.fit)
AIC(lm.fit4)
lm.all <- lm(Balance ~ ., data = Credit) # fits the full model
summary(lm.all)
summary(lm.all)$r.squared
AIC(lm.all)
library(car)
vif(lm.all) # computes the variance inflation factors
AIC(lm.all); BIC(lm.all) # to obtain the AIC and BIC values
intercept_only <- lm(Balance ~ 1 , data = Credit) # the model that has only the intercept parameter
summary(intercept_only)
forward <- step(intercept_only, direction="forward", scope=formula(lm.all), trace=0)
forward$anova # displays the forward selection procedure and the variables selected at each step
forward$coefficients # displays the coefficients for the best subset model fitted
lm.fitc <- lm(Balance ~ Rating+Income+Student+Limit+Cards+Age, data = Credit)
summary(lm.fitc)#Model M1
lm.fit3 <- lm(Balance ~ poly(Rating)+poly(Income)+Student+Limit+Cards+Age, data = Credit)
summary(lm.fit3)#Model M2
anova(lm.fitc, lm.fit3)
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
#objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(lstat=c(5,10,15))) # to predict Balance for a given value of Rating
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
#objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
#lm.fit$coefficients # to obtain the coefficient estimates
#lm.fit$fitted.values # to obtain the fitted values
#A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(lstat=c(5,10,15))) # to predict Balance for a given value of Rating
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit)
colnames(A)=c("Observed", "Predicted")
A[1:7,]
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(Rating=c(5,10,15))) # to predict Balance for a given value of Rating
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
#objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
#lm.fit$coefficients # to obtain the coefficient estimates
#lm.fit$fitted.values # to obtain the fitted values
#A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(Rating=c(5,10,15))) # to predict Balance for a given value of Rating
plot(Rating , Balance)
abline(lm.fit)
plot(predict(lm.fit), residuals(lm.fit), xlab="fitted values", ylab="residuals")
lm.fit1 <- lm(Balance ~ log(Rating) , data = Credit) # using the logarithm of Rating as the                                     predictor
lm.fit1
summary(lm.fit1) # detailed information about the fitted linear model
plot(predict(lm.fit1), residuals(lm.fit1), xlab="fitted values", ylab="residuals")
plot(log(Rating) , Balance, main="logarithmic transformation")
abline(lm.fit1)
lm.fit4 <- lm(Balance ~ poly(Rating, degree=4, raw=TRUE) , data = Credit) # produces the same output
summary(lm.fit4)
anova(lm.fit, lm.fit4)
AIC(lm.fit)
AIC(lm.fit4)
lm.all <- lm(Balance ~ ., data = Credit) # fits the full model
summary(lm.all)
summary(lm.all)$r.squared
AIC(lm.all)
library(car)
vif(lm.all) # computes the variance inflation factors
AIC(lm.all); BIC(lm.all) # to obtain the AIC and BIC values
intercept_only <- lm(Balance ~ 1 , data = Credit) # the model that has only the intercept parameter
summary(intercept_only)
forward <- step(intercept_only, direction="forward", scope=formula(lm.all), trace=0)
forward$anova # displays the forward selection procedure and the variables selected at each step
forward$coefficients # displays the coefficients for the best subset model fitted
lm.fit <- lm(Balance ~ Rating , data = Credit)
lm.fit
summary(lm.fit) # detailed information about the fitted linear model
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
A[1:7,] #(shows the first few observed and predicted values of house prices)
summary(lm.fit)$r.squared # to obtain the R-squared value
predict(lm.fit, data.frame(Rating=c(5,10,15))) # to predict Balance for a given value of Rating
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
colnames(A)=c("Observed", "Predicted")
#objects(lm.fit) #  to find out what other pieces of information are stored in lm.fit
lm.fit$coefficients # to obtain the coefficient estimates
lm.fit$fitted.values # to obtain the fitted values
A=cbind(Balance, lm.fit$fitted.values)
#colnames(A)=c("Observed", "Predicted")
ebp<-read.csv('RemoteEBPCLEANPartic_DATA_2022-12-05_0103.csv')
dat=read.csv('RemoteEBPCLEANPartic_DATA_2022-12-05_0103.csv')
dat==read.csv('RemoteEBPCLEANPartic_DATA_2022-12-05_0103.csv')
data==read.csv('RemoteEBPCLEANPartic_DATA_2022-12-05_0103.csv')
data=read.csv('RemoteEBPCLEANPartic_DATA_2022-12-05_0103.csv')
rm(list=ls())
graphics.off()
library(Hmisc)
data=read.csv('RemoteEBPCLEANPartic_DATA_2022-12-05_0103.csv')
path<-file.path("C:", "Users", "srava", "Desktop", "EBP", fsep="\\")
setwd(path)
data=read.csv('RemoteEBPCLEANPartic_DATA_2022-12-05_0103.csv')
library(readxl)
ebp<-read_excel("RemoteEBPCLEANPartic_DATA_2022-12-05_0056.csv")
ebp<-read.csv("RemoteEBPCLEANPartic_DATA_2022-12-05_0056.csv")
View(ebp)
ebp<-read.csv("RemoteEBPCLEANPartic_DATA_2022-12-05_0114.csv")
View(ebp)
na.omit(ebp)
ebp<-read.csv("RemoteEBPCLEANPartic_DATA_2022-12-05_0056.csv")
View(ebp)
View(ebp)
